1.postion: sticky;粘性定位元素（stickily positioned element）是计算后位置属性为 sticky 的元素
  使用条件
    1、父元素不能overflow:hidden或者overflow:auto属性。
    2、必须指定top、bottom、left、right4个值之一，否则只会处于相对定位
    3、父元素的高度不能低于sticky元素的高度
    4、sticky元素仅在其父元素内生效
2.react
    1.setSate书写的时候，可以直接穿一个带两个参数的函数，使得我们在重新修改state中值不用再定义变量来接收,直接和原来的值比较就可以了（每次的赋值会重新加载ui）
    2.props接收的值使用es6解构的方式来接收
      const { list,name  } = this.props
    3.定义的事件修改this指向的时候,不建议写在jsx中,而是写到 constructor里面
    4.ajax请求放在(componentDidMount)中,因为componentDidMount生命周期的话,打开只会渲染一次,这样会大大的提高了性能
    5.父子组件传值的时候,使用shouldComponentUpdate来判断父向子传的内容是否有变化,没变化的话,子组件就不需要渲染
 3.浏览器事件流
    DOM2级事件规定的事件流包括三个阶段：

    1、事件捕获阶段

    2、处于目标阶段

    3、事件冒泡阶段

    事件捕获阶段（Event Capturing）：
    按照事件捕获的思想，在此过程（click页面某元素）中，document对象会首先接收到click事件，然后事件沿着dom树依次向下，一直传播到实际目标，即div元素。但在事件流中的捕获阶段，实际目标div元素是不会接收到事件的，这就意味着没在捕获阶段，事件从document到再到后就停止了。（但IE9、Safari、Chrome、Firefox 和 Opera9.5 以及更高版本都会在捕获阶段触发事件对象上的事件）；下一个阶段是"处于目标"阶段，于是事件在发生，并在事件处理中被堪称冒泡阶段的一部分，最后，冒泡事件发生，事件又传播回文档。

    冒泡阶段（Event Bubbling）：
    事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点，即document对象。

    DOM2 与 DOM0区别

    DOM2级事件定义了两个方法，用于处理指定和删除事件处理程序的操作：

    ①.addEventListener()

    ②.removeEventListener()

    所有的DOM节点都包含这两个方法，而且接受三个参数：

    ①.要处理的事件名；

    ②.作为事件处理程序的函数；

    ③.一个 boolean 的值，如果值为true，表示在捕获阶段调用事件处理程序；如果是false，表示在冒泡阶段调用此事件处理程序。
4.事件委托原理：事件冒泡机制。
    优点：1.可以大量节省内存占用，减少事件注册。比如ul上代理所有li的click事件就很不错。
          2.可以实现当新增子对象时，无需再对其进行事件绑定，对于动态内容部分尤为合适
    缺点：事件代理的常用应用应该仅限于上述需求，如果把所有事件都用事件代理，可能会出现事件误判。即本不该被触发的事件被绑定上了事件。
6.call apply bind指的this是谁就是谁（bind不会调用，只会将当前的函数返回）
    fun.call(obj,a,b) 
    fun.apply(obj,[  ])
    fun.bind(obj,a,b)()
     1.以函数形式调用时，this永远都是window
     2.以方法的形式调用时，this是调用方法的对象
     3.以构造函数的形式调用时，this是新创建的那个对象
     4.使用call和apply调用时，this是指定的那个对象
     5.箭头函数：箭头函数的this看外层是否有函数           
        如果有，外层函数的this就是内部箭头函数的this            
        如果没有，就是window     
     6.特殊情况：通常意义上this指针指向为最后调用它的对象。这里需要注意的一点就是如果返回值是一个对象，那么this指向的就是那个返回的对象，如果返回值不是一个对象那么this还是指向函数的实例
 7.前端路由实现
     1.Pjax（PushState + Ajax）
        原理： 利用ajax请求替代a标签的默认跳转，然后利用html5的API修改url
        API:  history.pushState和 history.replaceState
        两个 API 都会操作浏览器的历史记录，而不会引起页面的刷新，pushState会增加一条新的历史记录，而replaceState则会替换当前的历史记录。（Ajax可以实现页面的无刷新操作，于是，返回的时候，通过URL或其他传参，我们就可以还原到Ajax之前的模样）
        浏览器的前进与后退，会触发window.onpopstate事件，通过绑定popstate事件，就可以根据当前URL地址中的查询内容让对应的菜单执行Ajax载入，实现Ajax的前进与后退效果。
        页面首次载入的时候，如果没有查询地址、或查询地址不匹配，则使用第一个菜单的Ajax地址的查询内容，并使用history.replaceState更改当前的浏览器历史，然后触发Ajax操作
     2.Hjax（Hash + Ajax）
        原理：url 中常会出现 #，一可以表示锚点（如回到顶部按钮的原理），二是路由里的锚点（hash）。Web 服务并不会解析 hash，也就是说 # 后的内容 Web 服务都会自动忽略，但是 JavaScript 是可以通过 window.location.hash 读取到的，读取到路径加以解析之后就可以响应不同路径的逻辑处理。
              hashchange 事件(监听 hash 变化触发的事件)，当用 window.location 处理哈希的改变时不会重新渲染页面，而是当作新页面加到历史记录中，这样我们跳转页面就可以在 hashchange 事件中注册 ajax 从而改变页面内容。
 8.解决vue路由跳转未匹配路径时出现空白页的问题
      1.导航守卫
        可以使用 router.beforeEach 注册一个全局前置守卫：
        const router = new VueRouter({ ... })
          router.beforeEach((to, from, next) => {
          // ...
          })
       2.匹配所有的路由
       3.重定向
9.react和vue 的数据变化方式
       1.在React以前我们可以使用componentWillReveiveProps来监听props的变换
       2.vue监听变量变化依靠的是watch
10.react-router：只更新变化的部分从而减少DOM性能消耗， a 跳转需要重新渲染
