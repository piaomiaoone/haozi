1.postion: sticky;粘性定位元素（stickily positioned element）是计算后位置属性为 sticky 的元素
  使用条件
    1、父元素不能overflow:hidden或者overflow:auto属性。
    2、必须指定top、bottom、left、right4个值之一，否则只会处于相对定位
    3、父元素的高度不能低于sticky元素的高度
    4、sticky元素仅在其父元素内生效
2.react
    1.setSate书写的时候，可以直接穿一个带两个参数的函数，使得我们在重新修改state中值不用再定义变量来接收,直接和原来的值比较就可以了（每次的赋值会重新加载ui）
    2.props接收的值使用es6解构的方式来接收
      const { list,name  } = this.props
    3.定义的事件修改this指向的时候,不建议写在jsx中,而是写到 constructor里面
    4.ajax请求放在(componentDidMount)中,因为componentDidMount生命周期的话,打开只会渲染一次,这样会大大的提高了性能
    5.父子组件传值的时候,使用shouldComponentUpdate来判断父向子传的内容是否有变化,没变化的话,子组件就不需要渲染
 3.浏览器事件流
    DOM2级事件规定的事件流包括三个阶段：

    1、事件捕获阶段

    2、处于目标阶段

    3、事件冒泡阶段

    事件捕获阶段（Event Capturing）：
    按照事件捕获的思想，在此过程（click页面某元素）中，document对象会首先接收到click事件，然后事件沿着dom树依次向下，一直传播到实际目标，即div元素。但在事件流中的捕获阶段，实际目标div元素是不会接收到事件的，这就意味着没在捕获阶段，事件从document到再到后就停止了。（但IE9、Safari、Chrome、Firefox 和 Opera9.5 以及更高版本都会在捕获阶段触发事件对象上的事件）；下一个阶段是"处于目标"阶段，于是事件在发生，并在事件处理中被堪称冒泡阶段的一部分，最后，冒泡事件发生，事件又传播回文档。

    冒泡阶段（Event Bubbling）：
    事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点，即document对象。

    DOM2 与 DOM0区别

    DOM2级事件定义了两个方法，用于处理指定和删除事件处理程序的操作：

    ①.addEventListener()

    ②.removeEventListener()

    所有的DOM节点都包含这两个方法，而且接受三个参数：

    ①.要处理的事件名；

    ②.作为事件处理程序的函数；

    ③.一个 boolean 的值，如果值为true，表示在捕获阶段调用事件处理程序；如果是false，表示在冒泡阶段调用此事件处理程序。
4.事件委托原理：事件冒泡机制。
    优点：1.可以大量节省内存占用，减少事件注册。比如ul上代理所有li的click事件就很不错。
          2.可以实现当新增子对象时，无需再对其进行事件绑定，对于动态内容部分尤为合适
    缺点：事件代理的常用应用应该仅限于上述需求，如果把所有事件都用事件代理，可能会出现事件误判。即本不该被触发的事件被绑定上了事件。
6.call apply bind指的this是谁就是谁（bind不会调用，只会将当前的函数返回）
    fun.call(obj,a,b) 
    fun.apply(obj,[  ])
    fun.bind(obj,a,b)()
     1.以函数形式调用时，this永远都是window
     2.以方法的形式调用时，this是调用方法的对象
     3.以构造函数的形式调用时，this是新创建的那个对象
     4.使用call和apply调用时，this是指定的那个对象
     5.箭头函数：箭头函数的this看外层是否有函数           
        如果有，外层函数的this就是内部箭头函数的this            
        如果没有，就是window     
     6.特殊情况：通常意义上this指针指向为最后调用它的对象。这里需要注意的一点就是如果返回值是一个对象，那么this指向的就是那个返回的对象，如果返回值不是一个对象那么this还是指向函数的实例
 7.前端路由实现
     1.Pjax（PushState + Ajax）
        原理： 利用ajax请求替代a标签的默认跳转，然后利用html5的API修改url
        API:  history.pushState和 history.replaceState
        两个 API 都会操作浏览器的历史记录，而不会引起页面的刷新，pushState会增加一条新的历史记录，而replaceState则会替换当前的历史记录。（Ajax可以实现页面的无刷新操作，于是，返回的时候，通过URL或其他传参，我们就可以还原到Ajax之前的模样）
        浏览器的前进与后退，会触发window.onpopstate事件，通过绑定popstate事件，就可以根据当前URL地址中的查询内容让对应的菜单执行Ajax载入，实现Ajax的前进与后退效果。
        页面首次载入的时候，如果没有查询地址、或查询地址不匹配，则使用第一个菜单的Ajax地址的查询内容，并使用history.replaceState更改当前的浏览器历史，然后触发Ajax操作
     2.Hjax（Hash + Ajax）
        原理：url 中常会出现 #，一可以表示锚点（如回到顶部按钮的原理），二是路由里的锚点（hash）。Web 服务并不会解析 hash，也就是说 # 后的内容 Web 服务都会自动忽略，但是 JavaScript 是可以通过 window.location.hash 读取到的，读取到路径加以解析之后就可以响应不同路径的逻辑处理。
              hashchange 事件(监听 hash 变化触发的事件)，当用 window.location 处理哈希的改变时不会重新渲染页面，而是当作新页面加到历史记录中，这样我们跳转页面就可以在 hashchange 事件中注册 ajax 从而改变页面内容。
 8.解决vue路由跳转未匹配路径时出现空白页的问题
      1.导航守卫
        可以使用 router.beforeEach 注册一个全局前置守卫：
        const router = new VueRouter({ ... })
          router.beforeEach((to, from, next) => {
          // ...
          })
       2.匹配所有的路由
       3.重定向
9.react和vue 的数据变化方式
       1.在React以前我们可以使用componentWillReveiveProps来监听props的变换
       2.vue监听变量变化依靠的是watch
10.react-router：只更新变化的部分从而减少DOM性能消耗， a 跳转需要重新渲染
11.JS 异步已经告一段落了，这里来一波小总结
      1. 回调函数（callback）
      setTimeout(() => {
          // callback 函数体
      }, 1000)

      缺点：回调地狱，不能用 try catch 捕获错误，不能 return

      回调地狱的根本问题在于：

      缺乏顺序性： 回调地狱导致的调试困难，和大脑的思维方式不符
      嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身，即（控制反转）
      嵌套函数过多的多话，很难处理错误
      ajax('XXX1', () => {
          // callback 函数体
          ajax('XXX2', () => {
              // callback 函数体
              ajax('XXX3', () => {
                  // callback 函数体
              })
          })
      })

      优点：解决了同步的问题（只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。）

      2. Promise
      Promise就是为了解决callback的问题而产生的。

      Promise 实现了链式调用，也就是说每次 then 后返回的都是一个全新 Promise，如果我们在 then 中 return ，return 的结果会被 Promise.resolve() 包装

      优点：解决了回调地狱的问题

      ajax('XXX1')
        .then(res => {
            // 操作逻辑
            return ajax('XXX2')
        }).then(res => {
            // 操作逻辑
            return ajax('XXX3')
        }).then(res => {
            // 操作逻辑
        })
      缺点：无法取消 Promise ，错误需要通过回调函数来捕获

      3. Generator
      特点：可以控制函数的执行，可以配合 co 函数库使用

      function *fetch() {
          yield ajax('XXX1', () => {})
          yield ajax('XXX2', () => {})
          yield ajax('XXX3', () => {})
      }
      let it = fetch()
      let result1 = it.next()
      let result2 = it.next()
      let result3 = it.next()
      4. Async/await
      async、await 是异步的终极解决方案

      优点是：代码清晰，不用像 Promise 写一大堆 then 链，处理了回调地狱的问题

      缺点：await 将异步代码改造成同步代码，如果多个异步操作没有依赖性而使用 await 会导致性能上的降低。

      async function test() {
        // 以下代码没有依赖性的话，完全可以使用 Promise.all 的方式
        // 如果有依赖性的话，其实就是解决回调地狱的例子了
        await fetch('XXX1')
        await fetch('XXX2')
        await fetch('XXX3')
      }
      下面来看一个使用 await 的例子：

      let a = 0
      let b = async () => {
        a = a + await 10
        console.log('2', a) // -> '2' 10
      }
      b()
      a++
      console.log('1', a) // -> '1' 1
      对于以上代码你可能会有疑惑，让我来解释下原因

      首先函数 b 先执行，在执行到 await 10 之前变量 a 还是 0，因为 await 内部实现了 generator ，generator 会保留堆栈中东西，所以这时候 a = 0 被保存了下来
      因为 await 是异步操作，后来的表达式不返回 Promise 的话，就会包装成 Promise.reslove(返回值)，然后会去执行函数外的同步代码
      同步代码执行完毕后开始执行异步代码，将保存下来的值拿出来使用，这时候 a = 0 + 10
      上述解释中提到了 await 内部实现了 generator，其实 await 就是 generator 加上 Promise的语法糖，且内部实现了自动执行 generator。如果你熟悉 co 的话，其实自己就可以实现这样的语法糖。
12.http协议报文
    1.请求报文(请求行/请求头/请求数据/空行)
        请求行
            求方法字段、URL字段和HTTP协议版本
            例如：GET /index.html HTTP/1.1
                get方法将数据拼接在url后面，传递参数受限
            请求方法：
                GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT
        请求头(key value形式)
            User-Agent：产生请求的浏览器类型。
            Accept：客户端可识别的内容类型列表。
            Host：主机地址
        请求数据
            post方法中，会把数据以key value形式发送请求
        空行
            发送回车符和换行符，通知服务器以下不再有请求头
    2.响应报文(状态行、消息报头、响应正文)
        状态行
        消息报头
        响应正文
